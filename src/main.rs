use serde_json::Value;
use tiny_http::{Response, Server};
use anyhow::{Error, Result, anyhow};
use std::{fs, env, path::PathBuf, str::FromStr};
use ureq::{tls::{TlsConfig, TlsProvider}, config::Config};

struct Pve {
    address: String,
    username: String,
    token: String,
    node: String
}

fn read_env(path: &PathBuf) -> Result<(Pve, String), Error> {
    let mut addr : Option<String> = None;
    let mut name : Option<String> = None;
    let mut token : Option<String> = None;
    let mut node : Option<String> = None;
    let mut listen_on : Option<String> = None;


    let content = fs::read_to_string(path).map_err(|e| anyhow!("failed to open .env file {}", e))?;
    let lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
    for line in lines {
        if line.trim().is_empty() || line.trim().starts_with('#') {
            continue;
        }
        if let Some((key, value)) = line.trim().split_once('=') {
            match key.trim() {
                "pve"       => addr = Some(value.trim().to_string()),                   // maybe split it as ip and port here
                "name"      => name = Some(value.trim().to_string()),
                "token"     => token = Some(value.trim().to_string()),
                "node"      => node = Some(value.trim().to_string()),
                "listen-on" => listen_on = Some(value.trim().to_string()),              // maybe better to pass as arg 
                _ => (),
            }
        }
    }
    let info = Pve { 
        address: (String::from(addr.unwrap())), 
        username: (String::from(name.unwrap())), 
        token: (String::from(token.unwrap())),
        node: (String::from(node.unwrap())), 
    };
    return Ok((info, listen_on.unwrap()));
}

fn assemble_vv(data: &Value, pve: &Pve) -> String {
    // virt-viewer seems to hate urls and pve returns url which causes virtviewer to fail 
    // ip was hardcoded at first so this idiotic ip assembly was made as a bodgeas an afterthough
    let temp = pve.address.clone();
    let ip = temp.as_str().rsplit(":").last().unwrap();
    let port = data["proxy"].as_str().unwrap().split(":").last().unwrap();
    let construct_address = format!("{}:{}", ip, port);
    
    let vv_content = format!(
        "# this file was generated by pve-spice-puller
            [virt-viewer]
            secure-attention={}
            tls-port={}
            title={}
            toggle-fullscreen={}
            type={}
            password={}
            proxy=http://{}
            ca={}
            host={}
            release-cursor={}
            delete-this-file=1
            host-subject={}",
        data["secure-attention"].as_str().unwrap(),
        data["tls-port"].as_i64().unwrap(),
        data["title"].as_str().unwrap(),
        data["toggle-fullscreen"].as_str().unwrap(),
        data["type"].as_str().unwrap(),
        data["password"].as_str().unwrap(),
        construct_address.as_str(),
        data["ca"].as_str().unwrap(),
        data["host"].as_str().unwrap(),
        data["release-cursor"].as_str().unwrap(),
        data["host-subject"].as_str().unwrap(),
    );
    vv_content
}

fn get_vv(pve: &Pve, vm: u8) -> Response<std::io::Cursor<Vec<u8>>> {
    
    let config = Config::builder()
    .tls_config(
        TlsConfig::builder()
        .provider(TlsProvider::Rustls)
        .disable_verification(true)             // DANGER DANGER DANGER TODO: FIX THIS SHIT SOMEHOW
        .build()
    )
    .build();
    
    let api = format!("https://{}/api2/json/nodes/{}/qemu/{}/spiceproxy", 
                                       pve.address, pve.node, vm.to_string());

    let agent = config.new_agent();
    let res = agent.post(api)
                                    .header("Authorization", &format!("PVEAPIToken={}={}", pve.username, pve.token))
                                    .send_empty();
    
    if let Err(e) = res {
        return Response::from_string(format!("smth gone wrong on pve side: {}", e)).with_status_code(500);
    }
    
    let res = res.unwrap();
    let body = res.into_body().read_to_string().unwrap();
    let json: Value = serde_json::from_str(&body).unwrap_or_else(|_| Value::Null);
    
    if json["data"].is_null() {
        return Response::from_string(format!("pve responded with nothing")).with_status_code(500);
    }
    
    let data = &json["data"];
    let header1: String = format!("Content-Type: application/x-virt-viewer");
    let header2: String = format!("Content-Disposition: attachment; filename=\"console_{}.vv\"", vm.to_string());
    
    Response::from_string(assemble_vv(data, &pve))
                                .with_header(tiny_http::Header::from_str(&header1).unwrap())
                                .with_header(tiny_http::Header::from_str(&header2).unwrap())
                                .with_status_code(200)
}

fn main() {
    let the_pve:Pve;
    let listen_addr;
    let mut env_path = env::current_exe().expect("something wrong with the .env file");
    // hack for locating .env both in dev and deploy
    if env_path.to_string_lossy().contains("target") {
        env_path.pop();
        env_path.pop();
    }
    env_path.pop();
    env_path.push(".env");
    
    match read_env(&env_path) {
        Ok((pve, listen_on)) => {
            println!("conf load ok");
            the_pve = pve; 
            listen_addr = listen_on;
        }
        Err(_) => {
            panic!("conf load not ok");
        }
    }
    
    let server = Server::http(&listen_addr).expect("failed to run server");
    println!("listening on {}/get_config/*vm_id*", &listen_addr);
    
    for request in server.incoming_requests() {
        if request.url().starts_with("/get_config") && request.method() == &tiny_http::Method::Get {
            let id= request.url().split("/").last().expect("vm number is incorrect"); //we are just assuming that everything is fine and dandy
            println!("serving a request from {}, providing config to {}", request.remote_addr().unwrap(), &id);
            let vm: u8 = id.parse::<u8>().expect("cant parse the vm number");
            let response = get_vv(&the_pve, vm);
            request.respond(response).unwrap();
        }
    }
}