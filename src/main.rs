use serde_json::Value;
use tiny_http::{Response, Server};
use std::{fs, str::FromStr};
use anyhow::{Error, Result, anyhow};
use std::path::PathBuf;
use ureq::tls::{TlsConfig, TlsProvider};
use ureq::config::Config;
use std::env;


struct Pve {
    address: String,
    username: String,
    token: String,
    node: String
}

fn read_creds(path: &PathBuf) -> Result<(Pve, String), Error> {
    let content = fs::read_to_string(path).map_err(|e| anyhow!("failed to open cred file {}", e))?;

    let mut addr = None;
    let mut name = None;
    let mut token = None;
    let mut node = None;
    let mut listen_on = None;

    let lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();

    for line in lines {
        if line.trim().is_empty() || line.trim().starts_with('#') {
            continue;
        }
        if let Some((key, value)) = line.trim().split_once('=') {
            match key.trim() {
                "pve"       => addr = Some(value.trim().to_string()),
                "name"      => name = Some(value.trim().to_string()),
                "token"     => token = Some(value.trim().to_string()),
                "node"      => node = Some(value.trim().to_string()),
                "listen-on" => listen_on = Some(value.trim().to_string()),
                _ => (),
            }
        }
    }
    let ret = Pve { 
        address: (String::from(addr.unwrap())), 
        username: (String::from(name.unwrap())), 
        token: (String::from(token.unwrap())),
        node: (String::from(node.unwrap())), 
    };
    return Ok((ret, listen_on.unwrap()));
}

fn assemble_vv(data: &Value, pve: &Pve) -> String {

    // this idiotic thing with ip construction was slapped together as an afterthought
    // virt-viewer wants ip and pve returns url which causes virtviewer to fail connection

    let temp = pve.address.clone();
    let ip = temp.as_str().rsplit(":").last().unwrap();
    let port = data["proxy"].as_str().unwrap().split(":").last().unwrap();
    let construct_address = format!("{}:{}", ip, port);

    let vv_content = format!(
            "# this file was generated by pve-spice-puller
            [virt-viewer]
            secure-attention={}
            tls-port={}
            title={}
            toggle-fullscreen={}
            type={}
            password={}
            proxy=http://{}
            ca={}
            host={}
            release-cursor={}
            delete-this-file=1
            host-subject={}",
            data["secure-attention"].as_str().unwrap(),
            data["tls-port"].as_i64().unwrap(),
            data["title"].as_str().unwrap(),
            data["toggle-fullscreen"].as_str().unwrap(),
            data["type"].as_str().unwrap(),
            data["password"].as_str().unwrap(),
            construct_address.as_str(),
            data["ca"].as_str().unwrap(),
            data["host"].as_str().unwrap(),
            data["release-cursor"].as_str().unwrap(),
            data["host-subject"].as_str().unwrap(),

        );
    vv_content
}

fn get_vv(pve: &Pve, vm: u8) -> Response<std::io::Cursor<Vec<u8>>> {

    let config = Config::builder()
    .tls_config(
        TlsConfig::builder()
            // requires the native-tls feature
            .provider(TlsProvider::Rustls)
            .disable_verification(true)
            .build()
    )
    .build();

    let api = format!("https://{}/api2/json/nodes/{}/qemu/{}/spiceproxy", pve.address, pve.node, vm.to_string());
    let agent = config.new_agent();
    let res = agent.post(api).header("Authorization", &format!("PVEAPIToken={}={}", pve.username, pve.token)).send_empty();

    if let Err(e) = res {
        return Response::from_string(format!("smth gone wrong on response: {}", e)).with_status_code(500);
    }

    let res = res.unwrap();
    let body = res.into_body().read_to_string().unwrap();
    let json: Value = serde_json::from_str(&body).unwrap_or_else(|_| Value::Null);

    
    if json["data"].is_null() {
        return Response::from_string(format!("pve responded wrong")).with_status_code(500);
    }
    
    let data = &json["data"];


    
    let header1: String = format!("Content-Type: application/x-virt-viewer");
    let header2: String = format!("Content-Disposition: attachment; filename=\"console_{}.vv\"", vm.to_string());

    Response::from_string(assemble_vv(data, &pve))
        .with_header(tiny_http::Header::from_str(&header1).unwrap())
        .with_header(tiny_http::Header::from_str(&header2).unwrap())
        .with_status_code(200)
        
    // todo!("not done yet, uses {}", vm);
}

fn main() {
    let the_pve:Pve;
    let listen_addr;
    let mut env_path = env::current_exe().expect("something wrong with the executable");
    if env_path.to_string_lossy().contains("target") {
        env_path.pop();
        env_path.pop();
    }
    env_path.pop();
    env_path.push(".env");
    match read_creds(&env_path) {
        Ok((pve, listen_on)) => {
            println!("conf load ok");
            the_pve = pve; 
            listen_addr = listen_on;
        }
        Err(_) => {
            panic!("conf load not ok");
        }
    }
    // let listen_addr = "0.0.0.0:8008";
    let server = Server::http(&listen_addr).expect("failed to run server");
    println!("listening on {}/get_config", &listen_addr);

    for request in server.incoming_requests() {
        if request.url().starts_with("/get_config") && request.method() == &tiny_http::Method::Get {
            let id= request.url().split("/").last().expect("vm number is incorrect");
            println!("serving a request from {}, providing config to {}", request.remote_addr().unwrap(), &id);
            let vm: u8 = id.parse::<u8>().expect("vm number is bad");
            let response = get_vv(&the_pve, vm);
            request.respond(response).unwrap();
        }
    }


}